import os
os.system("curl -s https://raw.githubusercontent.com/itsmesatyavir/endpoints/main/logo.json")
import argparse
import asyncio
import json
import random
import ssl
import time
import uuid
import base64
import aiohttp
import aiofiles
from aiohttp import ClientSession, TCPConnector
from colorama import Fore, Style, init
from loguru import logger
from websockets_proxy import Proxy, proxy_connect

init(autoreset=True)
CONFIG_FILE = "config.json"
DEVICE_FILE = "devices.json"
PROXY_FILE = "proxy.txt"
PING_INTERVAL = 30
CHECKIN_INTERVAL = 300
DIRECTOR_SERVER = "https://director.getgrass.io"

parser = argparse.ArgumentParser(description="GrassBot")
parser.add_argument("-p", "--proxy-file", help="Path to the proxy file")
args = parser.parse_args()

if args.proxy_file:
    PROXY_FILE = args.proxy_file

HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36 OPR/117.0.0.0",
    "Content-Type": "application/json",
    "Accept": "*/*",
    "Origin": "chrome-extension://lkbnfiajjmbhnfledhphioinpickokdi",
    "Accept-Encoding": "gzip, deflate, br, zstd",
    "Connection": "keep-alive"
}

ERROR_PATTERNS = [
    "Host unreachable",
    "[SSL: WRONG_VERSION_NUMBER]",
    "invalid length of packed IP address string",
    "Empty connect reply",
    "Device creation limit exceeded",
    "sent 1011 (internal error) keepalive ping timeout"
]

BANNED_PROXIES = {} 
GLOBAL_PROXY_MANAGER = None

def print_banner():
    os.system('cls' if os.name == 'nt' else 'clear')
    print(f"""{Fore.CYAN + Style.BRIGHT}

       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
      â–ˆâ–ˆâ•”â•â•â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â•â•     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•— â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
      â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘
      â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘ â•šâ•â•â•â•â–ˆâ–ˆâ•‘ â•šâ•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘
      â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•‘
       â•šâ•â•â•â•â•â•  â•šâ•â•  â•šâ•â• â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•â•     â•šâ•â•â•â•â•â•   â•šâ•â•â•â•â•â•     â•šâ•â•
{Style.RESET_ALL}""")
    print(f"{Fore.YELLOW}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print(f"â•‘ {Fore.CYAN}ğŸš€ GrassBot - Multi-User Farming System v8.01 {Fore.YELLOW}â•‘")
    print(f"â•‘ {Fore.LIGHTMAGENTA_EX}Developed by: @itsmesatyavir {Fore.YELLOW}                â•‘")
    print(f"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Style.RESET_ALL}\n")

async def get_ws_endpoints(device_id: str, user_id: str, proxy_url: str):
    url = f"{DIRECTOR_SERVER}/checkin"
    data = {
        "browserId": device_id,
        "userId": user_id,
        "version": "5.1.1",
        "extensionId": "lkbnfiajjmbhnfledhphioinpickokdi",
        "userAgent": HEADERS["User-Agent"],
        "deviceType": "extension"
    }
    connector = TCPConnector(ssl=False)
    async with ClientSession(connector=connector) as session:
        if proxy_url:
            try:
                async with session.post(url, json=data, headers=HEADERS, proxy=proxy_url) as response:
                    if response.status == 201:
                        try:
                            result = await response.json(content_type=None)
                        except Exception as e:
                            print(f"{Fore.RED}âœ– Error decoding JSON: {e}{Style.RESET_ALL}")
                            text = await response.text()
                            result = json.loads(text)
                        destinations = result.get("destinations", [])
                        token = result.get("token", "")
                        destinations = [f"wss://{dest}" for dest in destinations]
                        return destinations, token
                    else:
                        print(f"{Fore.RED}âœ– Failed to check in: Status {response.status}{Style.RESET_ALL}")
                        return [], ""
            except Exception as e:
                print(f"{Fore.RED}âœ– Error during POST request: {e}{Style.RESET_ALL}")
                return [], ""
        else:
            async with session.post(url, json=data, headers=HEADERS) as response:
                if response.status == 201:
                    try:
                        result = await response.json(content_type=None)
                    except Exception as e:
                        print(f"{Fore.RED}âœ– Error decoding JSON: {e}{Style.RESET_ALL}")
                        text = await response.text()
                        result = json.loads(text)
                    destinations = result.get("destinations", [])
                    token = result.get("token", "")
                    destinations = [f"wss://{dest}" for dest in destinations]
                    return destinations, token
                else:
                    print(f"{Fore.RED}âœ– Failed to check in: Status {response.status}{Style.RESET_ALL}")
                    return [], ""

class GlobalProxyManager:
    def __init__(self):
        self.all_proxies = set()
        self.available_proxies = set()
        self.assigned_proxies = {}
        self.lock = asyncio.Lock()
    
    async def load_proxies(self):
        async with self.lock:
            try:
                async with aiofiles.open(PROXY_FILE, "r") as file:
                    content = await file.read()
                self.all_proxies = set(line.strip() for line in content.splitlines() if line.strip())
                self.available_proxies = {p for p in self.all_proxies if p not in BANNED_PROXIES or time.time() >= BANNED_PROXIES[p]}
                print(f"{Fore.GREEN}âœ… Loaded {len(self.all_proxies)} total proxies, {len(self.available_proxies)} available{Style.RESET_ALL}")
            except Exception as e:
                print(f"{Fore.RED}âœ– Error loading proxies: {str(e)}{Style.RESET_ALL}")
    
    async def get_proxy(self, client_id: str) -> str:
        async with self.lock:
            if client_id in self.assigned_proxies:
                return self.assigned_proxies[client_id]
            
            if not self.available_proxies:
                await self.load_proxies()
            
            if self.available_proxies:
                proxy = random.choice(list(self.available_proxies))
                self.available_proxies.remove(proxy)
                self.assigned_proxies[client_id] = proxy
                return proxy
            return None
    
    async def release_proxy(self, client_id: str, proxy: str, ban: bool = False):
        async with self.lock:
            if client_id in self.assigned_proxies:
                del self.assigned_proxies[client_id]
            
            if ban:
                BANNED_PROXIES[proxy] = time.time() + 3600
                print(f"{Fore.RED}âŒ Banned proxy {proxy}{Style.RESET_ALL}")
            else:
                self.available_proxies.add(proxy)

class WebSocketClient:
    def __init__(self, proxy_url: str, device_id: str, user_id: str):
        self.proxy_url = proxy_url
        self.device_id = device_id
        self.user_id = user_id
        self.uri = None
        self.client_id = f"{user_id}_{device_id}"

    async def connect(self) -> bool:
        print(f"{Fore.GREEN}ğŸ–¥ï¸ [User: {self.user_id}] Device ID: {self.device_id}{Style.RESET_ALL}")
        while True:
            try:
                endpoints, token = await get_ws_endpoints(self.device_id, self.user_id, self.proxy_url)
                if not endpoints or not token:
                    print(f"{Fore.RED}âœ– [User: {self.user_id}] No valid WebSocket endpoints or token received{Style.RESET_ALL}")
                    return False
                self.uri = f"{endpoints[0]}?token={token}"
                print(f"{Fore.CYAN}ğŸ”— [User: {self.user_id}] Connecting to WebSocket URI: {self.uri}{Style.RESET_ALL}")

                await asyncio.sleep(0.1)
                ssl_context = ssl.create_default_context()
                ssl_context.check_hostname = False
                ssl_context.verify_mode = ssl.CERT_NONE

                async with proxy_connect(
                    self.uri,
                    proxy=Proxy.from_url(self.proxy_url),
                    ssl=ssl_context,
                    extra_headers=HEADERS
                ) as websocket:
                    ping_task = asyncio.create_task(self._send_ping(websocket))
                    checkin_task = asyncio.create_task(self._periodic_checkin())
                    try:
                        await self._handle_messages(websocket)
                    finally:
                        ping_task.cancel()
                        checkin_task.cancel()
                        try:
                            await ping_task
                        except asyncio.CancelledError:
                            pass
                        try:
                            await checkin_task
                        except asyncio.CancelledError:
                            pass
            except Exception as e:
                print(f"{Fore.RED}ğŸš« [User: {self.user_id}] Error with proxy {self.proxy_url}: {str(e)}{Style.RESET_ALL}")
                if any(pattern in str(e) for pattern in ERROR_PATTERNS) or "Rate limited" in str(e):
                    await GLOBAL_PROXY_MANAGER.release_proxy(self.client_id, self.proxy_url, ban=True)
                    return False
                await asyncio.sleep(5)

    async def _send_ping(self, websocket) -> None:
        while True:
            try:
                message = {
                    "id": str(uuid.uuid4()),
                    "version": "1.0.0",
                    "action": "PING",
                    "data": {}
                }
                await websocket.send(json.dumps(message))
                print(f"{Fore.BLUE}ğŸ“¤ [User: {self.user_id}] Sent PING to server{Style.RESET_ALL}")
                await asyncio.sleep(PING_INTERVAL)
            except Exception as e:
                print(f"{Fore.RED}ğŸš« [User: {self.user_id}] Error sending ping: {str(e)}{Style.RESET_ALL}")
                break

    async def _periodic_checkin(self) -> None:
        while True:
            await asyncio.sleep(CHECKIN_INTERVAL)
            print(f"{Fore.YELLOW}ğŸ”„ [User: {self.user_id}] Performing periodic check-in{Style.RESET_ALL}")
            await get_ws_endpoints(self.device_id, self.user_id, self.proxy_url)

    async def _handle_messages(self, websocket) -> None:
        handlers = {
            "AUTH": self._handle_auth,
            "PONG": self._handle_pong,
            "HTTP_REQUEST": self._handle_http_request
        }
        while True:
            response = await websocket.recv()
            message = json.loads(response)
            print(f"{Fore.GREEN}ğŸ“¥ [User: {self.user_id}] Received message: {message}{Style.RESET_ALL}")
            action = message.get("action")
            handler = handlers.get(action)
            if handler:
                await handler(websocket, message)
            else:
                print(f"{Fore.RED}âœ– [User: {self.user_id}] No handler for action: {action}{Style.RESET_ALL}")

    async def _handle_auth(self, websocket, message) -> None:
        auth_response = {
            "id": message["id"],
            "origin_action": "AUTH",
            "result": {
                "browser_id": self.device_id,
                "user_id": self.user_id,
                "user_agent": HEADERS["User-Agent"],
                "timestamp": int(time.time()),
                "device_type": "extension",
                "version": "5.1.1",
            }
        }
        await websocket.send(json.dumps(auth_response))
        print(f"{Fore.CYAN}ğŸ”‘ [User: {self.user_id}] Sent AUTH response{Style.RESET_ALL}")

    async def _handle_pong(self, websocket, message) -> None:
        pong_response = {
            "id": message["id"],
            "origin_action": "PONG"
        }
        await websocket.send(json.dumps(pong_response))
        print(f"{Fore.BLUE}ğŸ“ [User: {self.user_id}] Sent PONG response{Style.RESET_ALL}")

    async def _handle_http_request(self, websocket, message) -> None:
        data = message.get("data", {})
        method = data.get("method", "GET").upper()
        url = data.get("url")
        req_headers = data.get("headers", {})
        body = data.get("body")

        try:
            async with aiohttp.ClientSession() as session:
                async with session.request(method, url, headers=req_headers, data=body) as resp:
                    status = resp.status
                    if status == 429:
                        print(f"{Fore.RED}âœ– [User: {self.user_id}] HTTP_REQUEST returned 429 for proxy {self.proxy_url}{Style.RESET_ALL}")
                        raise Exception("Rate limited")
                    resp_headers = dict(resp.headers)
                    resp_bytes = await resp.read()
        except Exception as e:
            print(f"{Fore.RED}âœ– [User: {self.user_id}] HTTP_REQUEST error: {e}{Style.RESET_ALL}")
            raise e

        body_b64 = base64.b64encode(resp_bytes).decode()
        result = {
            "url": url,
            "status": status,
            "status_text": "",
            "headers": resp_headers,
            "body": body_b64
        }
        reply = {
            "id": message.get("id"),
            "origin_action": "HTTP_REQUEST",
            "result": result
        }
        await websocket.send(json.dumps(reply))
        print(f"{Fore.GREEN}ğŸŒ [User: {self.user_id}] Processed HTTP request to {url}{Style.RESET_ALL}")

class UserManager:
    def __init__(self, user_id: str, device_ids: list):
        self.user_id = user_id
        self.device_ids = device_ids
        self.active_clients = {}
        self.running = False

    async def start(self) -> None:
        self.running = True
        print(f"{Fore.MAGENTA}âš¡ Starting session for USER_ID: {self.user_id} with {len(self.device_ids)} devices{Style.RESET_ALL}")
        
        tasks = []
        for device_id in self.device_ids:
            task = asyncio.create_task(self._run_device(device_id))
            tasks.append(task)
        
        # Wait for all device tasks to complete
        await asyncio.gather(*tasks, return_exceptions=True)

    async def _run_device(self, device_id: str) -> None:
        client_id = f"{self.user_id}_{device_id}"
        
        while self.running:
            try:
                # Get a proxy for this device
                proxy = await GLOBAL_PROXY_MANAGER.get_proxy(client_id)
                if not proxy:
                    print(f"{Fore.RED}âœ– [User: {self.user_id}] No proxy available for device {device_id}{Style.RESET_ALL}")
                    await asyncio.sleep(30)
                    continue
                
                print(f"{Fore.CYAN}âš¡ [User: {self.user_id}] Starting device {device_id} with proxy: {proxy}{Style.RESET_ALL}")
                
                client = WebSocketClient(proxy, device_id, self.user_id)
                self.active_clients[device_id] = client
                
                result = await client.connect()
                
                if result is False:
                    print(f"{Fore.RED}âœ– [User: {self.user_id}] Device {device_id} failed, retrying with new proxy{Style.RESET_ALL}")
                    await asyncio.sleep(5)
                
            except Exception as e:
                print(f"{Fore.RED}âœ– [User: {self.user_id}] Device {device_id} error: {e}{Style.RESET_ALL}")
                await asyncio.sleep(10)
            
            finally:
                if device_id in self.active_clients:
                    del self.active_clients[device_id]

    def stop(self):
        self.running = False

class ProxyManager:
    def __init__(self, device_ids: list, user_id: str):
        self.device_ids = device_ids
        self.user_id = user_id
        self.active_proxies = set()
        self.all_proxies = set()

    async def load_proxies(self) -> None:
        try:
            async with aiofiles.open(PROXY_FILE, "r") as file:
                content = await file.read()
            self.all_proxies = set(line.strip() for line in content.splitlines() if line.strip())
            print(f"{Fore.GREEN}âœ… Loaded {len(self.all_proxies)} proxies{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}âœ– Error loading proxies: {str(e)}{Style.RESET_ALL}")

    async def start(self, max_proxies: int) -> None:
        await self.load_proxies()
        if not self.all_proxies:
            print(f"{Fore.RED}âœ– No proxies found in proxy.txt{Style.RESET_ALL}")
            return
        available_proxies = {p for p in self.all_proxies if p not in BANNED_PROXIES or time.time() >= BANNED_PROXIES[p]}
        if not available_proxies:
            print(f"{Fore.RED}âœ– No available proxies (all are banned).{Style.RESET_ALL}")
            return
        selected = random.sample(list(available_proxies), min(len(available_proxies), max_proxies))
        self.active_proxies = set(selected)
        print(f"{Fore.GREEN}ğŸš€ Starting {len(self.active_proxies)} active proxy connections{Style.RESET_ALL}")
        
        tasks = {asyncio.create_task(self._run_client(proxy, device_id)): (proxy, device_id) 
                for proxy, device_id in zip(self.active_proxies, self.device_ids)}

        while True:
            done, pending = await asyncio.wait(tasks.keys(), return_when=asyncio.FIRST_COMPLETED)
            for task in done:
                proxy, device_id = tasks.pop(task)
                if task.result() is False:
                    print(f"{Fore.RED}âœ– Proxy {proxy} failed; removing and rotating.{Style.RESET_ALL}")
                    self.active_proxies.remove(proxy)
                    await self.load_proxies()
                    remaining = {p for p in self.all_proxies if p not in self.active_proxies and 
                               (p not in BANNED_PROXIES or time.time() >= BANNED_PROXIES[p])}
                    if remaining:
                        new_proxy = random.choice(list(remaining))
                        self.active_proxies.add(new_proxy)
                        new_task = asyncio.create_task(self._run_client(new_proxy, device_id))
                        tasks[new_task] = (new_proxy, device_id)
                        print(f"{Fore.YELLOW}ğŸ”„ Rotated to new proxy: {new_proxy}{Style.RESET_ALL}")

    async def _run_client(self, proxy: str, device_id: str) -> bool:
        print(f"{Fore.CYAN}âš¡ Starting client with proxy: {proxy}{Style.RESET_ALL}")
        client = WebSocketClient(proxy, device_id, self.user_id)
        return await client.connect()

def setup_output():
    # Remove all file logging and only keep console output
    logger.remove()
    logger.add(lambda msg: print(msg, end=""),
               format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{message}</cyan>",
               level="INFO", colorize=True)

async def load_user_config() -> dict:
    try:
        with open(CONFIG_FILE, "r") as config_file:
            config_data = json.load(config_file)
        return config_data if "user_ids" in config_data else {}
    except Exception as e:
        print(f"{Fore.RED}âœ– Error loading configuration: {str(e)}{Style.RESET_ALL}")
        return {}

async def load_device_ids() -> dict:
    try:
        with open(DEVICE_FILE, "r") as device_file:
            device_data = json.load(device_file)
        if isinstance(device_data.get("device_ids"), list):
            # Convert old format to new format
            old_devices = device_data["device_ids"]
            device_data = {"users": {}}
            return device_data
        return device_data if "users" in device_data else {"users": {}}
    except Exception as e:
        print(f"{Fore.RED}âœ– Error loading device IDs: {str(e)}{Style.RESET_ALL}")
        return {"users": {}}

async def save_device_ids(device_data: dict) -> None:
    try:
        with open(DEVICE_FILE, "w") as device_file:
            json.dump(device_data, device_file, indent=4)
        total_devices = sum(len(devices) for devices in device_data.get("users", {}).values())
        print(f"{Fore.GREEN}âœ… Saved {total_devices} device IDs for {len(device_data.get('users', {}))} users!{Style.RESET_ALL}")
    except Exception as e:
        print(f"{Fore.RED}âœ– Error saving device IDs: {str(e)}{Style.RESET_ALL}")

async def user_input() -> dict:
    print(f"\n{Fore.YELLOW}âš™ï¸ Multi-User Configuration Setup{Style.RESET_ALL}")
    print(f"{Fore.CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€{Style.RESET_ALL}")
    
    user_ids_input = input(f"{Fore.YELLOW}ğŸ”‘ Enter your USER IDs (comma separated): {Style.RESET_ALL}")
    user_ids = [uid.strip() for uid in user_ids_input.split(",") if uid.strip()]
    
    if not user_ids:
        print(f"{Fore.RED}âœ– No valid user IDs entered!{Style.RESET_ALL}")
        return {}
    
    devices_per_user = {}
    for user_id in user_ids:
        while True:
            try:
                num_devices = int(input(f"{Fore.YELLOW}ğŸ“± Enter number of devices for user {user_id}: {Style.RESET_ALL}"))
                if num_devices > 0:
                    devices_per_user[user_id] = num_devices
                    break
                else:
                    print(f"{Fore.RED}âœ– Please enter a positive number{Style.RESET_ALL}")
            except ValueError:
                print(f"{Fore.RED}âœ– Please enter a valid number{Style.RESET_ALL}")
    
    config_data = {
        "user_ids": user_ids,
        "devices_per_user": devices_per_user
    }
    
    with open(CONFIG_FILE, "w") as config_file:
        json.dump(config_data, config_file, indent=4)
    
    print(f"{Fore.GREEN}âœ… Configuration saved for {len(user_ids)} USER IDs{Style.RESET_ALL}")
    return config_data

async def setup_devices(config: dict) -> dict:
    user_ids = config["user_ids"]
    devices_per_user = config.get("devices_per_user", {})
    
    existing_device_data = await load_device_ids()
    device_data = {"users": {}}
    
    for user_id in user_ids:
        if user_id in existing_device_data.get("users", {}):
            existing_devices = existing_device_data["users"][user_id]
            use_existing = input(f"{Fore.YELLOW}ğŸ”‘ User {user_id} has {len(existing_devices)} existing devices. Use them? (y/n): {Style.RESET_ALL}").strip().lower()
            if use_existing == 'y':
                device_data["users"][user_id] = existing_devices
                continue
        
        num_devices = devices_per_user.get(user_id, 1)
        device_ids = [str(uuid.uuid4()) for _ in range(num_devices)]
        device_data["users"][user_id] = device_ids
        print(f"{Fore.GREEN}âœ¨ Created {num_devices} device IDs for user {user_id}{Style.RESET_ALL}")
    
    await save_device_ids(device_data)
    return device_data

async def main() -> None:
    global GLOBAL_PROXY_MANAGER
    
    print_banner()
    setup_output()
    
    # Initialize global proxy manager
    GLOBAL_PROXY_MANAGER = GlobalProxyManager()
    await GLOBAL_PROXY_MANAGER.load_proxies()

    config = await load_user_config()
    if not config or not config.get("user_ids"):
        config = await user_input()

    user_ids = config["user_ids"]
    device_data = await setup_devices(config)

    print(f"\n{Fore.YELLOW}ğŸš€ Starting Multi-User GrassBot{Style.RESET_ALL}")
    print(f"{Fore.CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€{Style.RESET_ALL}")
    print(f"{Fore.GREEN}ğŸ‘¥ Users: {len(user_ids)}{Style.RESET_ALL}")
    
    total_devices = sum(len(devices) for devices in device_data["users"].values())
    print(f"{Fore.GREEN}ğŸ“± Total Devices: {total_devices}{Style.RESET_ALL}")
    print(f"{Fore.GREEN}ğŸ”Œ Available Proxies: {len(GLOBAL_PROXY_MANAGER.available_proxies)}{Style.RESET_ALL}")
    
    # Create user managers
    user_managers = []
    for user_id in user_ids:
        user_device_ids = device_data["users"].get(user_id, [])
        if user_device_ids:
            manager = UserManager(user_id, user_device_ids)
            user_managers.append(manager)
            print(f"{Fore.BLUE}ğŸ‘¤ User {user_id}: {len(user_device_ids)} devices{Style.RESET_ALL}")
    
    if not user_managers:
        print(f"{Fore.RED}âœ– No valid users with devices found!{Style.RESET_ALL}")
        return
    
    # Start all user managers concurrently
    tasks = [asyncio.create_task(manager.start()) for manager in user_managers]
    
    try:
        await asyncio.gather(*tasks)
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}â¹ï¸ Stopping all user sessions...{Style.RESET_ALL}")
        for manager in user_managers:
            manager.stop()

if __name__ == '__main__':
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print(f"\n{Fore.RED}ğŸ‘‹ Shutting down gracefully...{Style.RESET_ALL}")
    except Exception as e:
        print(f"{Fore.RED}âœ– Fatal error: {str(e)}{Style.RESET_ALL}")
